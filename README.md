# test-webfullstack

채용을 위한 프로젝트형 문제는 지원자의 기술 능력과 문제 해결 능력을 평가할 수 있도록 구체적이면서도 실무와 연관된 문제로 구성하는 것이 좋습니다. Node.js와 Java 기반의 웹 서비스를 개발하는 회사라는 배경을 고려하여, 다음과 같은 문제를 제안할 수 있습니다.

### 프로젝트: 간단한 웹 API 구축 및 통합

#### 요구 사항:
1. **서비스 개요**: 사용자는 책을 등록하고, 조회하며, 삭제할 수 있는 간단한 '도서 관리 API'를 개발하세요. 이 API는 사용자 인증 기능을 포함하며, 책 정보는 데이터베이스에 저장됩니다.

2. **기술 요구 사항**:
   - **백엔드**: Node.js (Express.js) 또는 Java (Spring Boot) 중 하나 선택.
   - **데이터베이스**: MySQL 또는 MongoDB 사용 가능.
   - **인증 및 권한**: JWT(JSON Web Token)를 이용한 사용자 인증 기능 추가.
   - **API 엔드포인트**:
     - `POST /books`: 새로운 책을 등록합니다. (제목, 저자, 출판일)
     - `GET /books`: 모든 책 목록을 조회합니다.
     - `GET /books/:id`: 특정 책의 상세 정보를 조회합니다.
     - `DELETE /books/:id`: 특정 책을 삭제합니다.
   - **에러 처리**: 잘못된 요청이나 서버 오류에 대한 적절한 에러 메시지와 상태 코드를 반환하세요.

3. **추가 요구 사항**:
   - **테스트**: API 엔드포인트별로 단위 테스트를 작성하세요. (Jest for Node.js or JUnit for Java)
   - **문서화**: API 사용 방법을 설명하는 간단한 README 작성.
   - **버전 관리**: Git을 이용하여 프로젝트를 관리하고, 코드 리뷰를 위해 GitHub, GitLab 또는 Bitbucket과 같은 플랫폼에 저장하세요.

4. **옵션 사항** (추가 점수 항목):
   - 캐시(Cache) 기능을 Redis로 구현하여 책 목록 조회 성능 최적화.
   - Docker를 사용한 컨테이너화 및 배포 자동화.
   - CI/CD 파이프라인을 구축하여 코드 푸시 시 자동 테스트 및 배포.

#### 평가 기준:
- **코드 품질**: 코드 가독성, 유지보수성, 모듈화 여부를 중점적으로 평가합니다.
- **기술적 깊이**: 데이터베이스와 인증 시스템의 구현, API의 성능 최적화 등을 평가합니다.
- **문서화 및 테스트**: API 문서화와 테스트 코드의 충실도를 확인합니다.
- **문제 해결 능력**: 발생할 수 있는 예외 상황에 대한 처리 능력과 문제 해결 방법을 평가합니다.

이 문제는 지원자가 실무에서 접할 수 있는 여러 기술을 직접 활용하게 하므로, 그들의 실력을 종합적으로 평가할 수 있을 것입니다.


프론트엔드와 백엔드가 분리된 마이크로서비스 아키텍처 기반의 프로젝트 과제를 통해 지원자의 다양한 기술 스택 활용 능력과 마이크로서비스 설계 능력을 평가할 수 있습니다. 이를 위한 적합한 과제를 제안하겠습니다.

### 프로젝트: 마이크로서비스 기반 '사용자 및 주문 관리 시스템'

#### 요구 사항:
1. **서비스 개요**: 사용자는 프론트엔드에서 회원 가입을 하고, 로그인 후 주문을 생성 및 조회할 수 있습니다. 백엔드는 '사용자 관리 서비스'와 '주문 관리 서비스'로 나누어져 있으며, 두 서비스는 각각 독립된 마이크로서비스로 운영됩니다.

2. **기술 요구 사항**:
   - **프론트엔드**: 
     - React, Vue.js, 또는 Angular 중 하나를 사용하여 싱글 페이지 애플리케이션(SPA) 구현.
     - API 호출을 통해 백엔드와 통신하며, 상태 관리 라이브러리 (Redux, Vuex 등)를 사용하여 로그인 상태와 주문 목록을 관리.
     - 사용자에게 회원가입, 로그인, 주문 목록 조회 및 주문 생성/취소 기능을 제공.
  
   - **백엔드**:
     - Node.js (Express.js) 또는 Java (Spring Boot)를 사용하여 두 개의 마이크로서비스를 각각 개발.
       1. **사용자 관리 서비스**:
          - 회원가입 및 로그인 기능 제공 (JWT를 통한 인증).
          - 사용자 정보 저장 및 관리.
       2. **주문 관리 서비스**:
          - 로그인한 사용자의 주문 생성, 조회, 취소 기능.
          - 각 주문은 사용자 ID와 연결되어 있으며, 주문 목록을 사용자별로 필터링 가능.
  
   - **데이터베이스**:
     - 사용자 관리 서비스는 **MySQL** 또는 **PostgreSQL**을 사용.
     - 주문 관리 서비스는 **MongoDB** 또는 **Cassandra**와 같은 NoSQL 데이터베이스를 사용하여 비정형 데이터를 저장.
  
   - **API 통신**:
     - 마이크로서비스 간 통신은 **REST API** 또는 **gRPC**로 구현.
     - API Gateway를 사용하여 단일 진입점을 제공하고, 각 서비스로 요청을 라우팅.
  
   - **인증 및 권한**:
     - JWT(JSON Web Token)를 사용하여 인증 및 권한 관리.
  
   - **프론트엔드 & 백엔드 통신**:
     - 백엔드 API 호출을 통해 사용자 관리 및 주문 기능 구현.
     - CORS 처리 및 에러 핸들링 포함.

3. **추가 요구 사항**:
   - **테스트**:
     - 프론트엔드: 주요 컴포넌트에 대한 단위 테스트 (Jest, React Testing Library 등 사용).
     - 백엔드: API 단위 테스트 작성 (Jest for Node.js or JUnit for Java).
   - **문서화**:
     - API 문서화는 **Swagger** 또는 **Postman**을 통해 수행.
   - **버전 관리**:
     - Git을 이용하여 프로젝트를 관리하고, 코드 리뷰를 위해 GitHub, GitLab 또는 Bitbucket에 저장.
  
4. **옵션 사항** (추가 점수 항목):
   - **CI/CD**: GitHub Actions, GitLab CI/CD 또는 Jenkins를 이용한 자동 배포 파이프라인 구축.
   - **컨테이너화**: Docker를 사용하여 각 마이크로서비스를 컨테이너화하고, **Docker Compose**를 사용하여 로컬 환경에서 전체 서비스 실행.
   - **클라우드 배포**: AWS, GCP 또는 Azure의 클라우드 서비스를 사용하여 실제 환경에 배포.
   - **로드 밸런싱** 및 **서비스 디스커버리**: Nginx나 **Kubernetes**를 사용하여 서비스 간 로드 밸런싱과 디스커버리 기능 추가.

#### 평가 기준:
- **마이크로서비스 설계 능력**: 서비스 간의 독립성, API 통신 및 데이터베이스 설계 능력을 평가.
- **프론트엔드-백엔드 통합**: 프론트엔드와 백엔드 간의 원활한 API 통신 및 UI/UX 흐름을 평가.
- **확장성 및 유연성**: 마이크로서비스의 확장 가능성, 유지보수성, 모듈화 여부.
- **테스트 및 문서화**: 테스트 코드의 충실도와 API 문서화 여부를 중점적으로 확인.
- **DevOps 관련 역량**: 컨테이너화, 자동화된 테스트 및 배포 파이프라인 구축 능력.

이 과제는 실무에 가까운 상황을 기반으로 하여, 지원자의 프론트엔드와 백엔드 기술 역량뿐만 아니라, 마이크로서비스 아키텍처 설계 및 DevOps 역량까지 종합적으로 평가할 수 있는 좋은 기준이 될 것입니다.



프로젝트 과제를 위해 제안된 마이크로서비스 아키텍처에서는 두 개의 주요 마이크로서비스가 있고, 각각 독립적인 데이터베이스를 사용합니다. 아래에 각 서비스에 맞는 **데이터베이스 스키마(DB Schema)**를 제시하겠습니다.

### 1. 사용자 관리 서비스 (User Management Service) - **MySQL 또는 PostgreSQL**

이 서비스는 관계형 데이터베이스를 사용하며, 사용자 인증 및 관리와 관련된 데이터를 저장합니다.

#### 테이블: `users`
| 컬럼명          | 데이터 타입      | 설명                           |
|----------------|-----------------|-------------------------------|
| `id`           | INT (PK, Auto Increment) | 사용자의 고유 ID                |
| `username`     | VARCHAR(255)     | 사용자 이름 (Unique)            |
| `email`        | VARCHAR(255)     | 사용자 이메일 (Unique)          |
| `password`     | VARCHAR(255)     | 해시 처리된 비밀번호              |
| `created_at`   | TIMESTAMP        | 계정 생성일                     |
| `updated_at`   | TIMESTAMP        | 마지막 정보 수정일               |

- **인덱스**: `username`, `email`에 인덱스 추가 (유니크 속성).
- **설명**: 각 사용자는 `username`과 `email`을 통해 고유하게 식별되며, 비밀번호는 해시 처리되어 저장됩니다.

### 2. 주문 관리 서비스 (Order Management Service) - **MongoDB 또는 Cassandra**

이 서비스는 비정형 데이터를 처리하기 위해 NoSQL 데이터베이스를 사용합니다. 주문 정보는 사용자의 ID와 연결되며, 여러 개의 주문을 사용자마다 저장할 수 있습니다.

#### 컬렉션: `orders`
```json
{
  "_id": ObjectId(),
  "user_id": Number,          // 사용자 관리 서비스의 사용자의 고유 ID
  "order_items": [
    {
      "product_name": String,   // 주문한 상품명
      "quantity": Number,       // 상품 수량
      "price": Number           // 상품 가격
    }
  ],
  "total_price": Number,        // 총 주문 금액
  "status": String,             // 주문 상태 (e.g., "pending", "shipped", "delivered", "cancelled")
  "created_at": Date,           // 주문 생성 날짜
  "updated_at": Date            // 마지막 주문 업데이트 날짜
}
```

- **주문 상태(status)**: 주문의 상태는 "pending", "shipped", "delivered", "cancelled" 등의 값을 가질 수 있습니다.
- **인덱스**: `user_id`에 인덱스를 추가하여 사용자의 주문을 빠르게 조회할 수 있도록 설정.

#### 주문 관리 서비스의 주요 특징:
- **order_items**: 배열로 저장된 주문 항목들은 각 상품의 이름, 수량, 가격을 포함합니다.
- **total_price**: 총 주문 금액은 각 주문 항목의 가격과 수량을 기반으로 계산됩니다.
- **NoSQL 데이터베이스**는 비정형 데이터를 효율적으로 관리할 수 있도록 유연한 스키마 구조를 가집니다.

### 3. 서비스 간 관계
- **사용자 관리 서비스**와 **주문 관리 서비스**는 독립적으로 운영되지만, `user_id`를 통해 연결됩니다.
- **주문 관리 서비스**에서 `user_id`는 사용자 관리 서비스의 `id`와 매칭됩니다. 즉, 주문을 생성하거나 조회할 때 사용자 관리 서비스에서 제공된 `user_id`를 통해 특정 사용자의 주문을 관리합니다.

### ERD 다이어그램
1. **사용자 관리 서비스 (MySQL)**:
   - 단일 `users` 테이블
   - 사용자 정보는 관계형 DB에서 관리되며, 비밀번호는 해시된 상태로 저장.
2. **주문 관리 서비스 (MongoDB)**:
   - 단일 `orders` 컬렉션
   - 각 주문에는 사용자 ID와 여러 주문 항목이 포함.

#### 요약
이 DB 스키마는 마이크로서비스의 독립성과 유연성을 극대화하면서, 사용자와 주문 간의 관계를 명확하게 정의합니다. 각 서비스는 자신만의 데이터베이스를 가지며, 필요한 부분만 서로 연결하여 데이터 일관성을 유지할 수 있습니다.



